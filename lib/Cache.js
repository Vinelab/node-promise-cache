// Generated by CoffeeScript 1.7.1
(function() {
  var Cache,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Cache = (function() {

    /*
     * Create a new Cache instance.
     *
     * @param {object} Q The promise manager.
     * @param {object} Manager The cache store manager. (check /lib/stores)
     * @param {object} Crypto node's crypto module
     * @return Cache
     */
    function Cache(Q, Manager, Crypto, config) {
      this.Q = Q;
      this.Manager = Manager;
      this.Crypto = Crypto;
      this.getCacheKey = __bind(this.getCacheKey, this);
      this.prefix = (config != null) && ((config != null ? config.prefix : void 0) != null) ? config.prefix : 'pcache';
      this.default_ttl = (config != null) && ((config != null ? config.ttl : void 0) != null) ? config.ttl : 60;
    }


    /**
      * Get the cache key.
      *
      * @param {mixed} key
      * @return string
     */

    Cache.prototype.getCacheKey = function(key) {
      var hash;
      if (typeof key === 'string') {
        return "" + this.prefix + ":" + key;
      }
      hash = this.Crypto.createHash('md5').update(JSON.stringify({
        _key: key
      })).digest('hex');
      return "" + this.prefix + ":" + hash;
    };


    /*
     * Store an item in the cache for a given number of seconds.
     *
     * @param {mixed} key
     * @param {mixed} value
     * @param {int} ttl
     * @return {Q.promise} Deferred Promise.
     */

    Cache.prototype.put = function(key, value, ttl) {
      var dfd, mapped;
      if (ttl == null) {
        ttl = this.default_ttl;
      }
      dfd = this.Q.defer();
      key = this.getCacheKey(key);
      mapped = JSON.stringify({
        _cached: value
      });
      this.Manager.setFor(key, mapped, ttl, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /*
     * Store an item in the cache indefinitely.
     *
     * @param {mixed} key
     * @param {mixed} value
     * @return {Q.promise}
     */

    Cache.prototype.forever = function(key, value) {
      var dfd, mapped;
      dfd = this.Q.defer();
      key = this.getCacheKey(key);
      mapped = JSON.stringify({
        _cached: value
      });
      this.Manager.set(key, mapped, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /**
     * Get an item from cache if it exists,
     * otherwise execute and get the value from the promise.
     *
     * @param {mixed} key
     * @param {Q.promise}
     */

    Cache.prototype.remember = function(key, ttl, promise) {
      var dfd;
      dfd = this.Q.defer();
      this.get(key).then((function(_this) {
        return function(stored) {
          if (!stored) {
            return promise.then(function(data) {
              return _this.put(key, data, ttl).then(function() {
                return dfd.resolve(data);
              });
            });
          } else {
            return dfd.resolve(stored);
          }
        };
      })(this));
      return dfd.promise;
    };


    /*
     * Just like remember(), get an item from the cache
     * or store the resulting value from the promise.
     *
     * @param {mixed} key
     * @param {Q.promise}
     */

    Cache.prototype.rememberForever = function(key, promise) {
      var dfd;
      dfd = this.Q.defer();
      this.get(key).then((function(_this) {
        return function(stored) {
          if (!stored) {
            return promise.then(function(data) {
              _this.forever(key, data);
              return dfd.resolve(data);
            });
          } else {
            return dfd.resolve(stored);
          }
        };
      })(this));
      return dfd.promise;
    };


    /*
     * Determine if an item exists in the cache.
     *
     * @param {mixed} key
     * @return {Q.promise}
     */

    Cache.prototype.has = function(key) {
      var dfd;
      dfd = this.Q.defer();
      key = this.getCacheKey(key);
      this.Manager.has(key, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /*
     * Get the remaining TTL (Time To Live) of an item in the cache.
     *
     * @param {mixed} key
     */

    Cache.prototype.ttl = function(key) {
      var dfd;
      dfd = this.Q.defer();
      key = this.getCacheKey(key);
      this.Manager.ttl(key, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /**
     * Retrieve an item from the cache by key.
     *
     * @param {mixed} key
     * @return {Q.promise}
     */

    Cache.prototype.get = function(key) {
      var dfd;
      dfd = this.Q.defer();
      this.Manager.get(this.getCacheKey(key), function(err, result) {
        var num, reduced;
        if (err) {
          return dfd.reject(err);
        }
        if (!result) {
          return dfd.resolve(result);
        }
        num = parseInt(result);
        if (!isNaN(num)) {
          return dfd.resolve(num);
        }
        reduced = JSON.parse(result)._cached;
        return dfd.resolve(reduced);
      });
      return dfd.promise;
    };


    /*
     * Remove an item from the cache by key.
     *
     * @param {mixed} key
     * @return {Q.promise}
     */

    Cache.prototype.forget = function(key) {
      var dfd;
      dfd = this.Q.defer();
      this.Manager.del(this.getCacheKey(key), function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /*
     * Remove all items from the cacheKey
     *
     * @return {Q.promise}
     */

    Cache.prototype.flush = function() {
      var dfd;
      dfd = this.Q.defer();
      this.Manager.flush(function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /*
     * Increment the value of an item in the cache.
     *
     * @param {mixed} key
     * @param {int} count (Default 1)
     * @return {Q.promise}
     */

    Cache.prototype.increment = function(key, count) {
      var dfd;
      if (count == null) {
        count = 1;
      }
      dfd = this.Q.defer();
      this.Manager.increment(this.getCacheKey(key), count, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };


    /*
     * Decrement the value of an item in the cache.
     * @param {mixed} key
     * @param {int} count (Default 1)
     * @return {Q.promise}
     */

    Cache.prototype.decrement = function(key, count) {
      var dfd;
      if (count == null) {
        count = 1;
      }
      dfd = this.Q.defer();
      this.Manager.decrement(this.getCacheKey(key), count, function(err, result) {
        if (err) {
          return dfd.reject(err);
        }
        return dfd.resolve(result);
      });
      return dfd.promise;
    };

    return Cache;

  })();

  module.exports.klass = Cache;

  module.exports.instance = function(Q, Manager, Crypto) {
    return new Cache(Q, Manager, Crypto);
  };

  module.exports.create = function(config) {
    var Crypto, Manager, Q;
    Q = require('q');
    Crypto = require('crypto');
    Manager = (config != null) && ((config != null ? config.store : void 0) != null) ? store : require('./stores/RedisStore').instance(null, config);
    return new Cache(Q, Manager, Crypto, config);
  };

}).call(this);
